---
title: "Recommender Systems"
subtitle: "Mini-Challenge 2 - Content-based Recommender"
author: "Pascal Berger, Lea Bütler & Joël Grosjean"
date: "10. Juni 2022"
output:
  html_notebook:
    toc: true
    toc_depth: 4
    df_print: paged
    toc_float:
      collapsed: true
      smooth_scroll: true
    theme: united
    highlight: tango
    code_folding: hide
    
---
<!--   pdf_document: -->
<!--     latex_engine: xelatex -->
<!--     number_sections: true -->
<!--     extra_dependencies: ["flafter"] -->
<!-- header-includes: -->
<!--   - \usepackage{fontspec} -->
<!--   - \setmainfont{TeX Gyre Heros} -->

R-Version: **[Default] [32-bit] C:\\Program Files\\R\\R-4.1.0**

In diesem Notebook wird ein Content Based Recommender und anschliessend eine Off-line Evaluierung von Top-N Empfehlungen des generierten Recommender erstellt. Erneut wird aus dem Paket Recommenderlab der 'MovieLense' Datensatz verwendet.
Für die Erstellung des Recommenders wird hier die Cosine Similarity angewandt.

Grosse Funktionen werden in einem 'helper.R' file ausgelagert.

```{r echo=FALSE, cache=FALSE, results=FALSE, comment=FALSE, warning=FALSE}
# clear environment
rm(list = ls())

# nötige Packete
packages <- c("tidyverse", "data.table", "lubridate", "ggplot2", "ggthemes", "recommenderlab", "knitr", 'pals', 'RColorBrewer', 'lattice', 'grid', 'gridExtra', 'tinytex')

# Noch nicht installierte Pakete installieren
installed_packages <- packages %in% rownames(installed.packages())

if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Laden der Packete
invisible(lapply(packages, library, character.only = TRUE))

# Importieren von Funktionene aus helper file
source("helper.R")

# Import font
# update.packages(ask = FALSE, checkBuilt = TRUE)
# tinytex::install_tinytex()
# tinytex::tlmgr_update()
# tinytex::tlmgr_install("tex-gyre")

# change options
options(dplyr.summarise.inform = FALSE)
```

***
## Erzeugung von Film- & Nutzerprofilen
#### 1. MovieLense Daten einlesen
```{r}
# Daten importieren
data(MovieLense)

# dataframe erstellen
movies <- as(MovieLense, "data.frame")
movies <- movies %>% mutate_if(is.character, as.factor)
```
Hier lesen wir die Daten ein und wandeln sie zur besseren Einsicht in ein Dataframe um.

#### 2. Binäre User-Liked-Items Matrix für alle Nutzer erzeugen.
```{r warning=FALSE}
movies_binary <- movies %>% mutate(rating = ifelse(rating > 3, 1, 0))
movies_wider <- pivot_wider(movies_binary, id_cols = user, names_from = item, values_from = rating)
rownames(movies_wider) <- movies_wider$user
movies_wider['user'] <- NULL
user_movie_matrix <- as.matrix(movies_wider)

user_liked_item <- as(binarize(MovieLense, minRating = 4), 'matrix') * 1
user_liked_item[1:3, 1:3]
```
Für die Binäre User-Liked Matrix wurde die Grenze für ein gutes Rating bei >4 gesetzt. Also alle Filme, welche mit einem Rating von 3 oder weniger bewertet wurden, sind als schlecht bewertet definiert (also 0), wobei Filme mit Bewertungen von 4 oder 5 als gut bewertet definiert sind (1).

#### 3. Dimension der User-Liked-Items Matrix prüfen und ausgeben.
```{r}
print_dim(user_liked_item)
```
In der Binären User-Liked_matrix sind 943 Users und 1664 bewertete Filme vorhanden. Dies entspricht der Dimension der Ursprungsdaten.

#### 4. Movie-Genre Matrix für alle Filme erzeugen.
```{r}
genres <- MovieLenseMeta
genres <- genres %>% select("title",'unknown':'Western')
rownames(genres) <- genres$title
genres['title'] <- NULL
movie_genre_matrix <- as.matrix(genres)
movie_genre_matrix[1:4,1:3]
```
Als nächster Schritt wurde eine 'movie_genre_matrix' erstellt, welche alle Filme mit den mit den dazugehörigen Genres aufgellistet sind. Zu erkennen ist, dass Filme mehreren Genres angehören können, und somit diverse neue Genreprofile mit verschiedenen Genrekombinationen vorhanden sind.

#### 5. Dimension der Movie-Genre Matrix prüfen und ausgeben.
```{r}
print_dim(movie_genre_matrix)
```
WIe bereits erwähnt sind in dieser Matrix alle 1664 Filme einem oder mehreren von 19 Genres zugeordnet.

#### 6. Anzahl unterschiedlicher Filmprofile bestimmen und visualisieren.

```{r}
nr_diff_movies <- user_liked_item %*% movie_genre_matrix
nr_diff_movies <- as.data.frame(nr_diff_movies)

nr_diff_movies_mean <- rownames_to_column(nr_diff_movies)

nr_diff_movies_mean <- pivot_longer(nr_diff_movies_mean, cols = !rowname, names_to = 'genre', values_to = 'count')
nr_diff_movies_mean <- nr_diff_movies_mean %>% group_by(genre) %>% summarize(count = mean(count))


nr_diff_movies_mean %>% mutate(genre = fct_reorder(genre, count)) %>% 
  ggplot(aes(x = genre, y = count)) + 
  geom_col(fill = 'steelblue') +
  coord_flip() +
  scale_y_continuous(expand = c(0,0), limits = c(0, 30)) +
  geom_text(aes(label = round(count, 2)), hjust=-0.2, color = 'black') +
  labs(
    title = "Duchschnittliche Anzahl positiv bewerteter Filme pro Genre",
    x = element_blank(), 
    y = "Anzahl",
    fill = element_blank()
  ) +
  theme_classic() + 
  theme(
    text = element_text(size = 12),
    legend.position = 'bottom'
  )
```
Hier sehen wir die allgemein am häufigsten positiv bewerteten Genres. Drama, Action und Comedy sind die beliebtesten Genres. Ein durchschnittlicher Nutzer hat also 25.78 Filme die mit Drama kategorisiert sind mit 4 oder 5 Sternen bewertet. Hier ist jedoch wichtig zu beachten, dass Genres oft in Kombination mit anderen Genres vorkommen, ein Film also mehreren Genres zugeteilt wurde.

```{r}
movie_genre_profile_matrix <- as.matrix(
    apply(
      movie_genre_matrix == 1,
      1, 
      function(a) paste0(colnames(movie_genre_matrix)[a], collapse = "-")
    )
  )

movie_genre_profile_df <- as.data.frame(movie_genre_profile_matrix)
movie_genre_profile_df$items <- rownames(movie_genre_profile_df)

#movie_genre_profile_list <- c(unique(movie_genre_profile_df$V1))
#movie_genre_profile_list <- strsplit(movie_genre_profile_list, "\n")
#length(movie_genre_profile_list)

head(movie_genre_profile_df,3) %>% select('V1')

movie_genre_profile_df <- movie_genre_profile_df %>%
  group_by(V1) %>%
  summarize(count = n()) %>%
  arrange(desc(count))

head_genre_profile <- movie_genre_profile_df %>% head(30)
tail_genre_profile <- anti_join(movie_genre_profile_df, head_genre_profile, by = 'V1')

movie_genre_profile_df <- rbind(head_genre_profile, c('Andere',sum(tail_genre_profile$count)))

movie_genre_profile_df <-  movie_genre_profile_df %>% 
  transform(count = as.numeric(count)) %>%
  mutate(highlight = ifelse(V1 == 'Andere', 'yes', 'no'))
```
In diesem Dataframe ist das Genre-Profil jedes Filmes zusammengefasst. Toy Story zum Beispiel wird als Genre-Profil `Animation-Children's-Comedy` zusammengefasst, was soweit sinnvoll erscheint.

```{r fig.width = 7.5, fig.height = 6}
ggplot(movie_genre_profile_df, aes(x = reorder(V1,count), y = count, fill = highlight)) + 
  geom_col() +
  scale_fill_manual(values = c('yes' = '#B47846', 'no' = 'steelblue'), guide = 'none') +
  coord_flip() +
  scale_y_continuous(expand = c(0,0), limits = c(0, 450)) +
  geom_text(aes(label = count), hjust=-0.2, color = 'black') +
  labs(
    title = "Verteilung der Filme nach Genre-Kombination",
    subtitle = 'Top 30 Kombinationen, von insgesamt 216',
    x = element_blank(), 
    y = "Anzahl Filme",
    fill = element_blank()
  ) +
  theme_classic() + 
  theme(
    text = element_text(size = 12),
    legend.position = 'bottom'
  )
```
In dem MovieLense Datenset sind insgesamt 216  verschiedene Genreprofile von den 1664 Filmen vertreten. Das bedeutet, es sind 216 verschiedene Genrekombinationen aus den 16 gegebenen Genres entstanden. Hier sehen wir also, dass das häufigste profil `Drama` alleine ist. Ganze 370 Filme wurden nur als Dramas kategorisiert.

#### 7. User-Genre-Profil Matrix mit Nutzerprofilen im Genre-Vektorraum erzeugen.
```{r}
user_genre_profil <- user_liked_item %*% movie_genre_matrix
user_genre_profil[1:5,1:5]
```
In dieser Matrix sind die Anzahl positiv bewerteter Filme pro Genre für jeden User dargestellt.

#### 8. Dimension der User-Genre-Profil Matrix prüfen und ausgeben.
```{r}
print_dim(user_genre_profil)
```
Die Matrix hat für alle 943 Nutzer eine Angabe für die 19 verschiedenen Genres.

#### 9. Anzahl unterschiedlicher Nutzerprofile bestimmen, wenn Stärke der GenreKombination (a) vollständig bzw. (b) nur binär berücksichtigt wird.
```{r}
user_genre_df <- as.data.frame(user_genre_profil)
user_genre_diff <- user_genre_df %>% mutate(across(.cols = everything(), .fns = ~ifelse(.x > 0, 1, 0)))

cat(paste("Users: ", as.character(dim(user_genre_df)[1])),
    paste("vollständig identisch:", as.character(dim(user_genre_df)[1] - count(distinct(user_genre_df)))),
    paste("binär identisch: ", as.character(dim(user_genre_df)[1] - count(distinct(user_genre_diff)))), sep = '\n')
```
Es gibt bei Betrachtung vollständiger Nutzerprofilen keine identischen Nutzerprofile.
Bei binärer Betrachtung sind hingegen fast 2/3 der Nutzerprofile identisch.

***
## Ähnlichkeit von Nutzern und Filmen
#### 1. Cosinus-Ähnlichkeit zwischen User-Genre- und Movie-Genre-Matrix berechnen.
```{r}

A_test.data <- c(1.5,2.5, 1.,0.5)
A_test <- matrix(A_test.data, nrow=2)
A_test

B_test.data <- c(0.5,1., 1.5,2.)
B_test <- matrix(B_test.data, nrow=2)
B_test

result <- calc_cos_similarity_twomtrx(A_test, B_test)

if((dim(result) == dim(B_test)) && (dim(result) == dim(A_test))) {
  print("dimensions match")
} else {
  print("dimensions do not match")
}
check.data <- c(0.79, 0.50, 0.87, 0.61)
check <- matrix(check.data, nrow=2)

if(max(abs(check - result)) < 1e-2){
  print("check match")
} else{
  print("check differs from result")
}


```
In diesem Beispiel wurde für zwei 2x2 Matrizen mit zufällig gewählten Werten die cosine similarity berechnet. Diese Berechnung wurde ebenfalls von Hand gemacht und mit der Implementierung abgegelichen. Zusätzlich wurden die Dimensionen der Inputmatrizen mit der resultierenden Matrix abgeglichen. Die Berechnung der Cosine Similarity ist somit korrekt.

```{r}
cat(
    print_dim(user_genre_profil),
    print_dim(movie_genre_matrix)
  )

similarity <- calc_cos_similarity_twomtrx(user_genre_profil, movie_genre_matrix)
```
Anschliessend wird die Cosine Similarity der user-genre und movie-genre Matrixberechnet. Für die Berechnung muss die zweite Matrix transponiert werden, damit für die Matrix Multiplikation die Anzahl Spalten der ersten Matrix der Anzahl Zeilen der zweiten übereinstimmt.

#### 2. Dimension der Matrix der Cosinus Ähnlichkeiten von Nutzern und Filmen prüfen uns ausgeben.
```{r}
similarity[1:3,1:3]
```

```{r}
print_dim(similarity)
```
Wie die Dimension schon erahnen lässt, ist in dieser Matrix die Similarity zwischen Usern und Filmen abgebildet. Die Matrix gibt also für alle 943 User eine Cosine Similarity mit jedem der 1664 Filme an.

#### 3. 5 Zahlen Statistik für Matrix der Cosinus Ähnlichkeiten prüfen uns ausgeben.
```{r}
summary(c(similarity))
```
Die similarities liegen zwischen 0 und 1, was bei Betrachtung der ausschliesslich positiven Bewertung Sinn ergibt. Da das Minimum bei 0 liegt, gibt es user-item Kombinationen welche keine Ähnlichkeiten aufweisen. Das Maximum von 0.9768 bedeutet, dass es sehr hohe Ähnlichkeiten zwischen User- und Film-Kombinationen gibt. Es gibt jedoch keine genau gleiche Kombination im gesamten Datensatz. Interessant ist, dass 1664 NA Werte bestehen. Dies hat zu bedeuten, dass es einen User gibt, welcher alle Filme negativ bewertet hat. Für diesen User können wir so keine Empfehlungen generieren. 

```{r}
cat(which(is.na(similarity), arr.ind = T)[1])
```
Wie hier gezeigt, ist dies der Nutzer 685.

#### 4. Cosinus Ähnlichkeiten von Nutzern und Filmen mit Dichteplot visualisieren.
```{r}
similarity_df <- as.data.frame(similarity)
similarity_df <- pivot_longer(similarity_df, cols=colnames(similarity_df)) %>% na.omit(value)

plot_similarity(similarity_df, "Alle 943 User")
```
Es fällt auf, dass sehr hohe Ähnlichkeiten sehr selten vorkommen. Auch auffallend ist, dass es eine Spitze bei Ähnlichkeiten von 0 gibt, also Filme welche überhaubt nicht zu einem Nutzer passen und demnach eine Cosine-Similarity von 0 besitzen. Auf diesem Diagramm ist es nicht all zu deutlich zu sehen, dass all diese Werte tatsächlich 0 sind, doch genau dies ist bei genauerem Betrachten der Daten aufgefallen. Ansonsten sind die Ähnlichkeiten relativ gleichmässig verteilt. Wobei am meisten Ähnlichkeiten ca. rund um 0.4 liegen.

```{r fig.width = 7.5, fig.height = 10}
plot_sim(similarity, "Cosinus similarity zwischen user-genre und movie-genre")
```
Bei der Visualisierung aller similarities wird sichtbar, dass sich die Farbunterschiede eher hoizontal ausprägen. Dies bedeutet, dass der Einfluss von Nutzern, die generell besser oder generell schlechter bewerten höher ist als die similarities zwischen den Filmen.

#### 5. Cosinus Ähnlichkeiten von Nutzern und Filmen mit Dichteplot für Nutzer “241”, “414”, “477”, “526”, “640” und “710”
```{r fig.width = 12, fig.height = 12}
selection <- as.data.frame(similarity)[c(241, 414, 477, 526, 640, 710), ]
movies <- colnames(selection)
selection$users <- rownames(selection)
selection_long <- selection %>% pivot_longer(cols = all_of(movies))

p1 <- plot_similarity(selection_long %>% filter(users == 241), "User 241")
p2 <- plot_similarity(selection_long %>% filter(users == 414), "User 414")
p3 <- plot_similarity(selection_long %>% filter(users == 477), "User 477")
p4 <- plot_similarity(selection_long %>% filter(users == 526), "User 526")
p5 <- plot_similarity(selection_long %>% filter(users == 640), "User 640")
p6 <- plot_similarity(selection_long %>% filter(users == 710), "User 710")

grid.arrange(p1, p2, p3, p4, p5, p6, ncol = 2, nrow = 3)
```
Hier wird nochmals sichtbar, dass das die similarities pro user sehr unterschiedlich sein können. Nummer 640 hat beispielsweise eine grössere similarity Ausprägung bei etwa 0.4. Häufig sind Buckel zu erkennen, was bedeutet dass Nutzer gewisse genres besser oder schlechter bewerten.

***
## Empfehlbare Filme
#### 1. Bewertete Filme maskieren, d.h. “Negativabzug” der User-Items Matrix erzeugen, um anschliessend Empfehlungen herzuleiten.
```{r}
movie_lense <- as(MovieLense,'matrix')

movies_masked <- as(MovieLense, "matrix")
movies_masked[!is.na(movies_masked)] <- 0
movies_masked[is.na(movies_masked)] <- 1

movie_lense[1:3,1:3]
movies_masked[1:3,1:3]
```
Hier sieht man, dass bei der neuen Matrix die nicht bewerteten Filme zu einer eins wurden und die bewerteten zu einer null.

#### 2. Zeilensumme des “Negativabzuges” der User-Items Matrix für die User “5”, “25”, “50” und “150” ausgeben.
```{r}
defined_user <- c(5, 25, 50, 150)
cat(
  for (i in defined_user) {
    cat('User',i,':', sum(movies_masked[i,]), 'Filme\n')
  }
)
```
Hier zu sehen sind die Anzahl nicht bewerteter Filme pro User. In anderen Worten sind dies also die empfehlbaren Filme. Von den 1664 Filmen haben die ausgewählten User nur einen kleinen Anteil gesehen.

#### 3. 5-Zahlen Statistik der Zeilensumme des “Negativabzuges” der User-Items Matrix bestimmen.
```{r}
rowsums_masked <- rowSums(movies_masked[, -1])
summary(rowsums_masked)
```
In dieser Statistik kann man sehen, dass der User den wenigsten nicht gesehenen Filme immernoch 928 der 1664 Filme nicht gesehen hat. Dies bedeutet für uns, dass wir maximal eine Top-928 Liste erstellen können. Der User mit den meisten nicht gesehenen Filmen hat 1645 der 1664 Filme nicht gesehen. Er hat also nur 19 Filme angeschaut. Ein durchschnittlicher Nutzer hat 1558 Filme nicht gesehen und somit 106 Filme gesehen.

***
## Top-N Empfehlungen
#### 1. Matrix für Bewertung aller Filme durch element-weise Multiplikation der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen und “Negativabzug” der User-Items Matrix erzeugen.
```{r}
rating_matrix <- similarity * movies_masked
rating_matrix[1:3,1:3]
```
In dieser Matrix sind die Cosinus-Ähnlichkeiten von Nutzern und Filmen zu sehen, wobei diese wenn der Film schon geschaut wurde Null ist.

#### 2. Dimension der Matrix für die Bewertung aller Filme prüfen.
```{r}
print_dim(rating_matrix)
```
Die Dimension dieser Matrix ist natürlich genauso wie die zwei multiplizierten Matrizen 943 User * 1664 Filme.

#### 3. Top-20 Listen pro Nutzer extrahieren.
```{r}
get_topn_recos <- function(matrix, n, user_id = 'all') {
  if (user_id == 'all') {
    as(as(matrix,'realRatingMatrix'),'data.frame') %>% arrange(desc(rating)) %>% group_by(user) %>% slice_head(n = n) %>% ungroup()
  }
  else {
   as(as(matrix,'realRatingMatrix'),'data.frame') %>% arrange(desc(rating)) %>% group_by(user) %>% slice_head(n = n) %>% ungroup() %>% filter(user %in% user_id) 
  }
}

recommendation <- get_topn_recos(rating_matrix, 20)
recommendation <- recommendation %>% transform(user = as.numeric(user))
head(recommendation,3)
```
Hier haben wir eine Funktion geschrieben, welche die Top-N Empfehlungen für alle Users zurückgibt, solange keine User-ID angegeben wird. Sonst bekommt man die Empfehlungen nur für die als Liste angegebenen User.

#### 4. Länge der Top-20 Listen pro Nutzer prüfen.
```{r}
reco_summary <- recommendation %>% group_by(user) %>% summarise(n = n())
summary(reco_summary)
```
Es fällt auf, dass es für alle User im Datensatz genau 20 Empfehlungen gibt. Bei genauerem betrachten fällt auf, dass es für 943 User 18'860 Empfehlungen geben müsste, es jedoch nur 18'840 Empfehlungen gibt. Dies liegt an dem User, welcher nur negative Bewertungen abgegeben hatte. Für diesen User gibt es momentan also einfach keine Empfehlungen. Man könnte dieses Problem natürlich verhindern indem man die Bewertungen dieses Users einfach anheben würde.

#### 5. Verteilung der minimalen Ähnlichkeit für Top-N Listen für N = 10, 20, 50 und 100 für alle Nutzer visuell vergleichen.
```{r fig.width = 7.5, fig.height = 12}
plot_min_similarity <- function(df, sub_title) {
  ggplot(df) +
    geom_density(aes(x = rating), fill = 'steelblue') +
    scale_y_continuous(expand = c(0,0)) +
    scale_x_continuous(expand = c(0,0), limits = c(0,1.02)) +
    labs(
      title = "Verteilung der Cosine-Similarity zwischen User und Filmen",
      subtitle = sub_title,
      x = "Cosine-Similarity", 
      y = "Dichte",
      fill = element_blank()
    ) +
    theme_classic() +
    theme(
      text = element_text(size = 12)
    )
}

recommendation <- get_topn_recos(rating_matrix, 10)
p1 <- plot_min_similarity(recommendation, 'Für Top-10 Recommendation')
recommendation <- get_topn_recos(rating_matrix, 20)
p2 <- plot_min_similarity(recommendation, 'Für Top-20 Recommendation')
recommendation <- get_topn_recos(rating_matrix, 50)
p3 <- plot_min_similarity(recommendation, 'Für Top-50 Recommendation')
recommendation <- get_topn_recos(rating_matrix, 100)
p4 <- plot_min_similarity(recommendation, 'Für Top-100 Recommendation')

grid.arrange(p1, p2, p3, p4, ncol = 1, nrow = 4)
```
Auf dieser Grafik kann man sehen, dass mit der Anzahl Empfehlungen auch die minimale Ähnlichkeit abnimmt. Bei einer Top-10 List ist die Tiefste Cosine-Similarity ca. 0.65. Bei einer Top-100 List hingegen, ist die minimale Cosine-Similarity unter 0.5.


#### 6. Top-20 Empfehlungen für Nutzer “5”, “25”, “50” und “150” visuell evaluieren.
```{r}
defined_user_lists <- get_topn_recos(rating_matrix, 20, c('5', '25', '50', '150'))
movie_genre_df <- as.data.frame(movie_genre_profile_matrix)
movie_genre_df$item<- rownames(movie_genre_df)
movie_genre_df$genre <- movie_genre_df$V1
movie_genre_df$V1 <- NULL
defined_user_lists <- merge(defined_user_lists, movie_genre_df, by = 'item')

#movie_genre_df
defined_user_lists
```
```{r fig.width = 10, fig.height = 10}
create_cleveland_plot_1 <- function(df, title) {
  ggplot(df, aes(genre, rating), height = 500, width = 7) +
    scale_color_discrete(labels = c("bestbewertete Filme", "Top-N Empfehlungen")) +
    coord_flip() +
    geom_line() +
    geom_point(aes(color = user)) +
    theme_minimal() +
    labs(
      title = title,
      x = element_blank(),
      y = "Rating (1 = gut, 0 = schlecht)",
      color = element_blank()
    ) +
    theme(
      text = element_text(size = 10),
      legend.position = 'bottom'
    )
}
create_cleveland_plot_1(defined_user_lists, 'Top-20 Empfehlungen für Nutzer 5, 25, 50, 150')
```


#### 7. Für Nutzer “133” und “555” Profil mit Top-N Empfehlungen für N = 20, 30, 40, 50 analysieren, visualisieren und diskutieren.
```{r}
# analyze_topn_recos(rating_matrix[c(133, 555),], c(20, 30, 40, 50))
```
TODO: Clevelandplot + diskussion
