---
title: "Content-based Recommender"
author: "Pascal Berger, Lea Bütler & Joël Grosjean"
output:
  html_notebook: default
  pdf_document: default
---
R-Version: **[Default] [32-bit] C:\\Program Files\\R\\R-4.1.0**

In folgendem Notebook werden anhand des `MovieLense` Datensatzes aus dem Paket RecommenderLab verschiedene Recommender erstellt. Es werden verschiedene Recommender und verschiedene Ähnlichkeiten verwendet, um diese zu vergleichen und auszuwerten. Ziel ist es, ein möglichst guter Recommender zu erstellen und zu verstehen wie dieser funktioniert. Zudem soll verstanden werden wie dieser bewertet wird und was in diesem Falle ein 'guter' Recommender bedeutet.

Dieses Notebook konzentriert sich auf Erkenntnisse von Auswertungen und Vergleichen. Um eine bessere Übersicht zu erhalten wurden grosse, sich widerholende Codes im Helperfile `helper.R` ausgelagert.

```{r echo=FALSE, cache=FALSE, results=FALSE, comment=FALSE, warning=FALSE}
# nötige Packete
packages <- c("tidyverse", "data.table", "lubridate", "ggplot2", "ggthemes", "recommenderlab", "knitr", 'pals', 'RColorBrewer', 'lattice', 'grid', 'gridExtra')

# Noch nicht installierte Pakete installieren
installed_packages <- packages %in% rownames(installed.packages())

if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Laden der Packete
invisible(lapply(packages, library, character.only = TRUE))

# Importieren von Funktionene aus helper file
source("helper.R")

# change options
options(dplyr.summarise.inform = FALSE)

# --------------------------- data wrangling -------------------------------------
# Daten importieren
data(MovieLense)

# dataframe erstellen
movies <- as(MovieLense, "data.frame")
movies <- movies %>% mutate_if(is.character, as.factor)

# breite version des dataframe erstellen
# movies_wider <- pivot_wider(
#   movies,
#   id_cols = user,
#   names_from = item,
#   values_from = rating,
#   values_fill = NULL,
# )
```

## Binäre User-Liked-Items Matrix für alle Nutzer erzeugen
```{r}
movies_binary <- movies %>% mutate(rating = ifelse(rating > 3, 1, 0))
movies_wider <- pivot_wider(movies_binary, id_cols = user, names_from = item, values_from = rating)
matrix <- as.matrix(movies_wider)
movies_wider
```
Für die Binäre User-Liked Matrix setzten wir die Grenze für ein gutes Rating bei >4. Also alle Filme, welche mit einem Rating von 3 oder weniger bewertet wurden, werden als schlecht bewertet definiert (also 0), wobei Filme mit Bewertungen von 4 oder 5 als gut bewertet definiert sind (1).


## Ähnlichkeit von Nutzern und Filmen

### Test

```{r}

A_test.data <- c(1,2,0,2,1,0,1,2,1)
A_test <- matrix(A_test.data, nrow=3)
A_test

B_test.data <- c(1,2,0,2,1,0,1,2,1)
B_test <- matrix(B_test.data, nrow=3)
B_test

result <- calc_cos_similarity_twomtrx(A_test, B_test)

if((dim(result) == dim(B_test)) && (dim(result) == dim(A_test))) {
  print("dimensions match")
} else {
  print("dimensions do not match")
}

result

```

Wie in diesem Beispiel ersichtlich wird, ist die Matrix symmetrisch...


```{r}

similarity <- calc_cos_similarity_twomtrx(user_genre, movie_genre)

```

```{r}
summary(similarity)
```


```{r}
plot_sim(similarity, "cosine similarity matrix between user-genre and movie-genre")
```


```{r}
selection <- similarity[c(241, 414, 477, 526, 640, 710), ]

plot_sim(selection, "cosine similarity user-genre and movie-genre selection")

```

### Empfehlbare Filme
## 1. Bewertete Filme maskieren, d.h. “Negativabzug” der User-Items Matrix erzeugen, um anschliessend Empfehlungen herzuleiten.
```{r}
movies_masked <- movies_wider
movies_masked[-1][movies_masked[-1] == 1] <- 0
movies_masked[is.na(movies_masked)] <- 1
movies_masked
```

## 2. Zeilensumme des “Negativabzuges” der User-Items Matrix für die User “5”, “25”, “50” und “150” ausgeben.
```{r}
defined_user <- c(5, 25, 50, 150)
defined_user
rowSums(movies_masked[defined_user, -1])
```
Hier zu sehen sind die anzahl nicht bewerteter filme pro user

## 3. 5-Zahlen Statistik der Zeilensumme des “Negativabzuges” der User-Items Matrix bestimmen.
```{r}
rowsums_masked <- rowSums(movies_masked[, -1])
summary(rowsums_masked)
```

## Top-N Empfehlungen
## 1.Matrix für Bewertung aller Filme durch element-weise Multiplikation der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen und “Negativabzug” der User-Items Matrix erzeugen.
```{r}
rating_matrix <- user_movie_matrix * movies_masked
```

## 2.Dimension der Matrix für die Bewertung aller Filme prüfen.
```{r}
dim(rating_matrix)
```

## 3.Top-20 Listen pro Nutzer extrahieren.
```{r}
get_topn_recos <- function(rating_matrix, n){
  herdöpfel <- as(rating_matrix, 'realmatrixmatrix')
  herdöpfel <- as(herdöpfel, 'data.frame')
  herdöpfel <- arrange(desc(herdöpfel$ratings)) %>%
    group_by(user) %>%
    slice(head(n)) %>%
    ungroup()
  return(herdöpfel)
}

recommendation <- get_topn_recos(rating_matrix, 20)
recommendation
```

## 4.Länge der Top-20 Listen pro Nutzer prüfen.
```{r}
summary(recommendation)
```

##5.Verteilung der minimalen Ähnlichkeit für Top-N Listen für N = 10, 20, 50 und 100 für alle Nutzer visuell vergleichen.
```{r}
analyze_topn_recos <- function(rating_matrix, list){
  recoms <- c()
  for (n in list) {
    recoms <- append(recoms, get_topn_recos(rating_matrix, n))
  }
  return(recoms)
}

analyze_topn_recos(rating_matrix, c(10, 20, 50, 100))
```
TODO: igewie visualisiere

##6.Top-20 Empfehlungen für Nutzer “5”, “25”, “50” und “150” visuell evaluieren.
```{r}
defined_user_lists <- get_topn_recos(ratingmatrix, 20) %>%
  filter(user == c(5, 25, 50, 50, 150)) %>%
  ungroup()

defined_user_lists
```
TODO: clevelandplot

##7.Für Nutzer “133” und “555” Profil mit Top-N Empfehlungen für N = 20, 30, 40, 50 analysieren, visualisieren und diskutieren.
```{r}
analyze_topn_recos(rating_matrix[c(133, 555),], c(20, 30, 40, 50))
```
TODO: Clevelandplot + diskussion
