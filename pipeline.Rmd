---
title: "Content-based Recommender"
author: "Pascal Berger, Lea Bütler & Joël Grosjean"
output:
  html_notebook: default
  pdf_document: default
---
R-Version: **[Default] [32-bit] C:\\Program Files\\R\\R-4.1.0**

In folgendem Notebook werden anhand des `MovieLense` Datensatzes aus dem Paket RecommenderLab verschiedene Recommender erstellt. Es werden verschiedene Recommender und verschiedene Ähnlichkeiten verwendet, um diese zu vergleichen und auszuwerten. Ziel ist es, ein möglichst guter Recommender zu erstellen und zu verstehen wie dieser funktioniert. Zudem soll verstanden werden wie dieser bewertet wird und was in diesem Falle ein 'guter' Recommender bedeutet.

Dieses Notebook konzentriert sich auf Erkenntnisse von Auswertungen und Vergleichen. Um eine bessere Übersicht zu erhalten wurden grosse, sich widerholende Codes im Helperfile `helper.R` ausgelagert.

```{r echo=FALSE, cache=FALSE, results=FALSE, comment=FALSE, warning=FALSE}
# nötige Packete
packages <- c("tidyverse", "data.table", "lubridate", "ggplot2", "ggthemes", "recommenderlab", "knitr", 'pals', 'RColorBrewer', 'lattice', 'grid', 'gridExtra')

# Noch nicht installierte Pakete installieren
installed_packages <- packages %in% rownames(installed.packages())

if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}

# Laden der Packete
invisible(lapply(packages, library, character.only = TRUE))

# Importieren von Funktionene aus helper file
source("helper.R")

# change options
options(dplyr.summarise.inform = FALSE)

# --------------------------- data wrangling -------------------------------------
# Daten importieren
data(MovieLense)

# dataframe erstellen
movies <- as(MovieLense, "data.frame")
movies <- movies %>% mutate_if(is.character, as.factor)

# breite version des dataframe erstellen
# movies_wider <- pivot_wider(
#   movies,
#   id_cols = user,
#   names_from = item,
#   values_from = rating,
#   values_fill = NULL,
# )
```
## 2.Binäre User-Liked-Items Matrix für alle Nutzer erzeugen.
```{r}
movies_binary <- movies %>% mutate(rating = ifelse(rating > 3, 1, 0))
movies_wider <- pivot_wider(movies_binary, id_cols = user, names_from = item, values_from = rating)
rownames(movies_wider) <- movies_wider$user
movies_wider['user'] <- NULL
user_movie_matrix <- as.matrix(movies_wider)
movies_wider
```
Für die Binäre User-Liked Matrix setzten wir die Grenze für ein gutes Rating bei >4. Also alle Filme, welche mit einem Rating von 3 oder weniger bewertet wurden, werden als schlecht bewertet definiert (also 0), wobei Filme mit Bewertungen von 4 oder 5 als gut bewertet definiert sind (1).

```{r}
binary_non_na <- as(binarize(MovieLense, minRating = 4), 'matrix') * 1
binary_non_na[1:3, 1:3]
```
Um 

## 3.Dimension der User-Liked-Items Matrix prüfen und ausgeben.
```{r}
dim(user_movie_matrix)
```

## 4.Movie-Genre Matrix für alle Filme erzeugen.
```{r}
genres <- MovieLenseMeta
genres <- genres %>% select("title",'unknown':'Western')
rownames(genres) <- genres$title
genres['title'] <- NULL
movie_genre_matrix <- as.matrix(genres)
genres
```

## 5.Dimension der Movie-Genre Matrix prüfen und ausgeben.
```{r}
dim(movie_genre_matrix)
```
```{r}
class(movie_genre_matrix)
```
```{r}
user_movie_matrix[1:3, 1:3]
```

```{r}
class(user_movie_matrix)
```


## 6.Anzahl unterschiedlicher Filmprofile bestimmen und visualisieren.
```{r}
movie_genre_profile_matrix <- as.matrix(apply(movie_genre_matrix == 1, 1, 
                                       function(a) paste0(colnames(movie_genre_matrix)[a], collapse = "")))
movie_genre_profile_df <- as.data.frame(movie_genre_profile_matrix)
movie_genre_profile_df$items <- rownames(movie_genre_profile_df)

#movie_genre_profile_list <- c(unique(movie_genre_profile_df$V1))
#movie_genre_profile_list <- strsplit(movie_genre_profile_list, "\n")
#length(movie_genre_profile_list)

movie_genre_profile_df
```
TODO: igewie die einzelne genreprofil zelle, inen df speichere und plotte(grafik vode slides vom dani, glaub folie 13)

In dem MovieLense Datenset sind insgesamt 216  verschiedene Genreprofile von den Filmen vertreten. Das bedeitet, es sind 216 verschiedene Genrekombinationen aus den 16 gegebenen Genres entstanden.
(r isch so en seich plötzlich bruuchsch nömm 'as(data, 'data.frame)' sondern 'as.data.frame(data)' WIESO????)

```{r}
movie_genre_profile_df <- movie_genre_profile_df %>%
  group_by(V1)
movie_genre_profile_df
```

```{r}
nr_diff_movies <- binary_non_na %*% movie_genre_matrix
nr_diff_movies <- as.data.frame(nr_diff_movies)

nr_diff_movies_mean <- rownames_to_column(nr_diff_movies)

nr_diff_movies_mean <- pivot_longer(nr_diff_movies_mean, cols = !rowname, names_to = 'genre', values_to = 'count')
nr_diff_movies_mean <- nr_diff_movies_mean %>% group_by(genre) %>% summarize(count = mean(count))

nr_diff_movies
```
TODO: Visualisierung der verschiedener Nutzerprofile ( siehe slide 13 Daniel)
In dieser Matrix ist zu sehen wie viele Filme pro genre mit mehr als 3 bewertet wurden, jeweils pro User.
```{r}
nr_diff_movies_mean
```

```{r}
nr_diff_movies_mean %>% mutate(genre = fct_reorder(genre, count)) %>% 
  ggplot(aes(x = genre, y = count)) + 
  geom_col(fill = 'steelblue') +
  coord_flip() +
  scale_y_continuous(expand = c(0,0), limits = c(0, 30)) +
  geom_text(aes(label = round(count, 2)), hjust=-0.2, color = 'black') +
  labs(
    title = "Duchschnittliche Anzahl positiv bewerteter Filme pro Genre",
    x = element_blank(), 
    y = "Anzahl",
    fill = element_blank()
  ) +
  theme_classic() + 
  theme(
    text = element_text(size = 12),
    legend.position = 'bottom'
  )
```

## 7.User-Genre-Profil Matrix mit Nutzerprofilen im Genre-Vektorraum erzeugen.

##8.Dimension der User-Genre-Profil Matrix prüfen und ausgeben.

## 9.Anzahl unterschiedlicher Nutzerprofile bestimmen, wenn Stärke der GenreKombination (a) vollständig bzw. (b) nur binär berücksichtigt wird.

## Ähnlichkeit von Nutzern und Filmen

## 1.Cosinus-Ähnlichkeit zwischen User-Genre- und Movie-Genre-Matrix berechnen.

### Test
```{r}

A_test.data <- c(1.5,2.5, 1.,0.5)
A_test <- matrix(A_test.data, nrow=2)
A_test

B_test.data <- c(0.5,1., 1.5,2.)
B_test <- matrix(B_test.data, nrow=2)
B_test

result <- calc_cos_similarity_twomtrx(A_test, B_test)

if((dim(result) == dim(B_test)) && (dim(result) == dim(A_test))) {
  print("dimensions match")
} else {
  print("dimensions do not match")
}
check.data <- c(0.79, 0.50, 0.87, 0.61)
check <- matrix(check.data, nrow=2)

if(max(abs(check - result)) < 1e-2){
  print("check match")
} else{
  print("check differs from result")
}


```

In diesem Beispiel wurde für zwei 2x2 Matrizen mit zufällig gewählten Werten die cosine similarity berechnet. Diese Berechnung wurde ebenfalls von Hand gemacht und mit der Implementierung abgegelichen. Zusätzlich wurden die Dimensionen der Inputvariablen mit deren des Resultates abgeglichen. Die Berechnung der Cosine Similarity sollte so korrekt sein.


Anschliessend wird die Cosine Similarity der user-genre und movie-genre Matrixberechnet.

```{r}
user_movie_non_na <- user_movie_matrix
user_movie_non_na[is.na(user_movie_non_na)] <- 0
user_movie_non_na[1:5, 1:5]
```


```{r}

similarity <- calc_cos_similarity_twomtrx(user_movie_non_na, t(movie_genre_matrix))

```

```{r}
summary(similarity)
```


```{r}
plot_sim(similarity, "cosine similarity matrix between user-genre and movie-genre")
```


```{r}
selection <- as.data.frame(similarity)[c(241, 414, 477, 526, 640, 710), ]
genres <- colnames(selection)
selection$users <- rownames(selection)
selection_long <- selection %>% pivot_longer(cols = genres)

ggplot(selection_long, aes(x=value, fill=users)) + geom_density(alpha=0.3) + 
    labs(title="Density plot Cosinus-Ähnlichkeiten ausgewählte users", subtitle="", x="similarity")
    
#plot_sim(selection, "cosine similarity user-genre and movie-genre selection")

```

### Empfehlbare Filme
## 1. Bewertete Filme maskieren, d.h. “Negativabzug” der User-Items Matrix erzeugen, um anschliessend Empfehlungen herzuleiten.
```{r}
movies_masked <- movies_wider
movies_masked[-1][movies_masked[-1] == 1] <- 0
movies_masked[is.na(movies_masked)] <- 1
movies_masked
```

## 2. Zeilensumme des “Negativabzuges” der User-Items Matrix für die User “5”, “25”, “50” und “150” ausgeben.
```{r}
defined_user <- c(5, 25, 50, 150)
defined_user
rowSums(movies_masked[defined_user, -1])
```
Hier zu sehen sind die anzahl nicht bewerteter filme pro user

## 3. 5-Zahlen Statistik der Zeilensumme des “Negativabzuges” der User-Items Matrix bestimmen.
```{r}
rowsums_masked <- rowSums(movies_masked[, -1])
summary(rowsums_masked)
```

## Top-N Empfehlungen
## 1.Matrix für Bewertung aller Filme durch element-weise Multiplikation der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen und “Negativabzug” der User-Items Matrix erzeugen.
```{r}
rating_matrix <- user_movie_matrix * movies_masked
```

## 2.Dimension der Matrix für die Bewertung aller Filme prüfen.
```{r}
dim(rating_matrix)
```

```{r}
rating_matrix
```


## 3.Top-20 Listen pro Nutzer extrahieren.
```{r}
get_topn_recos <- function(rating_matrix, n){
  herdöpfel <- as(rating_matrix, 'realRatingMatrix')
  herdöpfel <- as(herdöpfel, 'data.frame')
  herdöpfel <- arrange(desc(herdöpfel$ratings)) %>%
    group_by(user) %>%
    slice(head(n)) %>%
    ungroup()
  return(herdöpfel)
}

recommendation <- get_topn_recos(rating_matrix, 20)
recommendation
```

## 4.Länge der Top-20 Listen pro Nutzer prüfen.
```{r}
summary(recommendation)
```

##5.Verteilung der minimalen Ähnlichkeit für Top-N Listen für N = 10, 20, 50 und 100 für alle Nutzer visuell vergleichen.
```{r}
analyze_topn_recos <- function(rating_matrix, list){
  recoms <- c()
  for (n in list) {
    recoms <- append(recoms, get_topn_recos(rating_matrix, n))
  }
  return(recoms)
}

analyze_topn_recos(rating_matrix, c(10, 20, 50, 100))
```
TODO: igewie visualisiere

##6.Top-20 Empfehlungen für Nutzer “5”, “25”, “50” und “150” visuell evaluieren.
```{r}
defined_user_lists <- get_topn_recos(ratingmatrix, 20) %>%
  filter(user == c(5, 25, 50, 50, 150)) %>%
  ungroup()

defined_user_lists
```
TODO: clevelandplot

##7.Für Nutzer “133” und “555” Profil mit Top-N Empfehlungen für N = 20, 30, 40, 50 analysieren, visualisieren und diskutieren.
```{r}
analyze_topn_recos(rating_matrix[c(133, 555),], c(20, 30, 40, 50))
```
TODO: Clevelandplot + diskussion
